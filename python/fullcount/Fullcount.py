# Code generated by moonworm : https://github.com/moonstream-to/moonworm
# Moonworm version : 0.8.0

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer
from eth_typing.evm import ChecksumAddress


PROJECT_DIRECTORY = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
BUILD_DIRECTORY = os.path.join(PROJECT_DIRECTORY, "out", "Fullcount.sol")


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {raw_value}. Value must be one of: {','.join(TRUE_VALUES + FALSE_VALUES)}"
    )


def bytes_argument_type(raw_value: str) -> str:
    return raw_value


def get_abi_json(abi_name: str) -> List[Dict[str, Any]]:
    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        build = json.load(ifp)

    abi_json = build.get("abi")
    if abi_json is None:
        raise ValueError(f"Could not find ABI definition in: {abi_full_path}")

    return abi_json


def contract_from_build(abi_name: str) -> ContractContainer:
    # This is workaround because brownie currently doesn't support loading the same project multiple
    # times. This causes problems when using multiple contracts from the same project in the same
    # python project.
    PROJECT = project.main.Project("moonworm", Path(PROJECT_DIRECTORY))

    abi_full_path = os.path.join(BUILD_DIRECTORY, f"{abi_name}.json")
    if not os.path.isfile(abi_full_path):
        raise IOError(
            f"File does not exist: {abi_full_path}. Maybe you have to compile the smart contracts?"
        )

    with open(abi_full_path, "r") as ifp:
        foundry_build = json.load(ifp)

    build = {
        "type": "contract",
        "ast": foundry_build["ast"],
        "abi": foundry_build["abi"],
        "contractName": abi_name,
        "compiler": {
            "version": foundry_build["metadata"]["compiler"]["version"],
        },
        "language": foundry_build["metadata"]["language"],
        "bytecode": foundry_build["bytecode"]["object"],
        "sourceMap": foundry_build["bytecode"]["sourceMap"],
        "deployedBytecode": foundry_build["deployedBytecode"]["object"],
        "deployedSourceMap": foundry_build["deployedBytecode"]["sourceMap"],
        "pcMap": {},
    }

    return ContractContainer(PROJECT, build)


class Fullcount:
    def __init__(self, contract_address: Optional[ChecksumAddress]):
        self.contract_name = "Fullcount"
        self.address = contract_address
        self.contract = None
        self.abi = get_abi_json("Fullcount")
        if self.address is not None:
            self.contract: Optional[Contract] = Contract.from_abi(
                self.contract_name, self.address, self.abi
            )

    def deploy(self, seconds_per_phase: int, transaction_config):
        contract_class = contract_from_build(self.contract_name)
        deployed_contract = contract_class.deploy(seconds_per_phase, transaction_config)
        self.address = deployed_contract.address
        self.contract = deployed_contract
        return deployed_contract.tx

    def assert_contract_is_instantiated(self) -> None:
        if self.contract is None:
            raise Exception("contract has not been instantiated")

    def verify_contract(self):
        self.assert_contract_is_instantiated()
        contract_class = contract_from_build(self.contract_name)
        contract_class.publish_source(self.contract)

    def distance0_distribution(
        self, arg1: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.Distance0Distribution.call(
            arg1, block_identifier=block_number
        )

    def distance1_distribution(
        self, arg1: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.Distance1Distribution.call(
            arg1, block_identifier=block_number
        )

    def distance2_distribution(
        self, arg1: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.Distance2Distribution.call(
            arg1, block_identifier=block_number
        )

    def distance_gt2_distribution(
        self, arg1: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.DistanceGT2Distribution.call(
            arg1, block_identifier=block_number
        )

    def fullcount_version(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.FullcountVersion.call(block_identifier=block_number)

    def num_sessions(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.NumSessions.call(block_identifier=block_number)

    def seconds_per_phase(
        self, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.SecondsPerPhase.call(block_identifier=block_number)

    def session_state(
        self, arg1: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.SessionState.call(arg1, block_identifier=block_number)

    def staked_session(
        self,
        arg1: ChecksumAddress,
        arg2: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.StakedSession.call(
            arg1, arg2, block_identifier=block_number
        )

    def abort_session(self, session_id: int, transaction_config) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.abortSession(session_id, transaction_config)

    def commit_pitch(
        self, session_id: int, signature: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.commitPitch(session_id, signature, transaction_config)

    def commit_swing(
        self, session_id: int, signature: bytes, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.commitSwing(session_id, signature, transaction_config)

    def eip712_domain(self, block_number: Optional[Union[str, int]] = "latest") -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.eip712Domain.call(block_identifier=block_number)

    def get_session(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.getSession.call(session_id, block_identifier=block_number)

    def join_session(
        self,
        session_id: int,
        nft_address: ChecksumAddress,
        token_id: int,
        signature: bytes,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.joinSession(
            session_id, nft_address, token_id, signature, transaction_config
        )

    def pitch_hash(
        self,
        nonce: int,
        speed: int,
        vertical: int,
        horizontal: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.pitchHash.call(
            nonce, speed, vertical, horizontal, block_identifier=block_number
        )

    def random_sample(
        self,
        nonce0: int,
        nonce1: int,
        total_mass: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.randomSample.call(
            nonce0, nonce1, total_mass, block_identifier=block_number
        )

    def resolve(
        self,
        pitch: tuple,
        swing: tuple,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.resolve.call(pitch, swing, block_identifier=block_number)

    def reveal_pitch(
        self,
        session_id: int,
        nonce: int,
        speed: int,
        vertical: int,
        horizontal: int,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.revealPitch(
            session_id, nonce, speed, vertical, horizontal, transaction_config
        )

    def reveal_swing(
        self,
        session_id: int,
        nonce: int,
        kind: int,
        vertical: int,
        horizontal: int,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.revealSwing(
            session_id, nonce, kind, vertical, horizontal, transaction_config
        )

    def sample_outcome_from_distribution(
        self,
        nonce0: int,
        nonce1: int,
        distribution: List,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.sampleOutcomeFromDistribution.call(
            nonce0, nonce1, distribution, block_identifier=block_number
        )

    def session_hash(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.sessionHash.call(session_id, block_identifier=block_number)

    def session_progress(
        self, session_id: int, block_number: Optional[Union[str, int]] = "latest"
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.sessionProgress.call(
            session_id, block_identifier=block_number
        )

    def start_session(
        self,
        nft_address: ChecksumAddress,
        token_id: int,
        role: int,
        require_signature: bool,
        transaction_config,
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.startSession(
            nft_address, token_id, role, require_signature, transaction_config
        )

    def swing_hash(
        self,
        nonce: int,
        kind: int,
        vertical: int,
        horizontal: int,
        block_number: Optional[Union[str, int]] = "latest",
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.swingHash.call(
            nonce, kind, vertical, horizontal, block_identifier=block_number
        )

    def unstake_nft(
        self, nft_address: ChecksumAddress, token_id: int, transaction_config
    ) -> Any:
        self.assert_contract_is_instantiated()
        return self.contract.unstakeNFT(nft_address, token_id, transaction_config)


def get_transaction_config(args: argparse.Namespace) -> Dict[str, Any]:
    signer = network.accounts.load(args.sender, args.password)
    transaction_config: Dict[str, Any] = {"from": signer}
    if args.gas_price is not None:
        transaction_config["gas_price"] = args.gas_price
    if args.max_fee_per_gas is not None:
        transaction_config["max_fee"] = args.max_fee_per_gas
    if args.max_priority_fee_per_gas is not None:
        transaction_config["priority_fee"] = args.max_priority_fee_per_gas
    if args.confirmations is not None:
        transaction_config["required_confs"] = args.confirmations
    if args.nonce is not None:
        transaction_config["nonce"] = args.nonce
    return transaction_config


def add_default_arguments(parser: argparse.ArgumentParser, transact: bool) -> None:
    parser.add_argument(
        "--network", required=True, help="Name of brownie network to connect to"
    )
    parser.add_argument(
        "--address", required=False, help="Address of deployed contract to connect to"
    )
    if not transact:
        parser.add_argument(
            "--block-number",
            required=False,
            type=int,
            help="Call at the given block number, defaults to latest",
        )
        return
    parser.add_argument(
        "--sender", required=True, help="Path to keystore file for transaction sender"
    )
    parser.add_argument(
        "--password",
        required=False,
        help="Password to keystore file (if you do not provide it, you will be prompted for it)",
    )
    parser.add_argument(
        "--gas-price", default=None, help="Gas price at which to submit transaction"
    )
    parser.add_argument(
        "--max-fee-per-gas",
        default=None,
        help="Max fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--max-priority-fee-per-gas",
        default=None,
        help="Max priority fee per gas for EIP1559 transactions",
    )
    parser.add_argument(
        "--confirmations",
        type=int,
        default=None,
        help="Number of confirmations to await before considering a transaction completed",
    )
    parser.add_argument(
        "--nonce", type=int, default=None, help="Nonce for the transaction (optional)"
    )
    parser.add_argument(
        "--value", default=None, help="Value of the transaction in wei(optional)"
    )
    parser.add_argument("--verbose", action="store_true", help="Print verbose output")


def handle_deploy(args: argparse.Namespace) -> None:
    network.connect(args.network)
    transaction_config = get_transaction_config(args)
    contract = Fullcount(None)
    result = contract.deploy(
        seconds_per_phase=args.seconds_per_phase, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_verify_contract(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.verify_contract()
    print(result)


def handle_distance0_distribution(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.distance0_distribution(
        arg1=args.arg1, block_number=args.block_number
    )
    print(result)


def handle_distance1_distribution(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.distance1_distribution(
        arg1=args.arg1, block_number=args.block_number
    )
    print(result)


def handle_distance2_distribution(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.distance2_distribution(
        arg1=args.arg1, block_number=args.block_number
    )
    print(result)


def handle_distance_gt2_distribution(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.distance_gt2_distribution(
        arg1=args.arg1, block_number=args.block_number
    )
    print(result)


def handle_fullcount_version(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.fullcount_version(block_number=args.block_number)
    print(result)


def handle_num_sessions(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.num_sessions(block_number=args.block_number)
    print(result)


def handle_seconds_per_phase(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.seconds_per_phase(block_number=args.block_number)
    print(result)


def handle_session_state(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.session_state(arg1=args.arg1, block_number=args.block_number)
    print(result)


def handle_staked_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.staked_session(
        arg1=args.arg1, arg2=args.arg2, block_number=args.block_number
    )
    print(result)


def handle_abort_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.abort_session(
        session_id=args.session_id, transaction_config=transaction_config
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_commit_pitch(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.commit_pitch(
        session_id=args.session_id,
        signature=args.signature,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_commit_swing(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.commit_swing(
        session_id=args.session_id,
        signature=args.signature,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_eip712_domain(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.eip712_domain(block_number=args.block_number)
    print(result)


def handle_get_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.get_session(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_join_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.join_session(
        session_id=args.session_id,
        nft_address=args.nft_address,
        token_id=args.token_id,
        signature=args.signature,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_pitch_hash(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.pitch_hash(
        nonce=args.nonce_arg,
        speed=args.speed,
        vertical=args.vertical,
        horizontal=args.horizontal,
        block_number=args.block_number,
    )
    print(result)


def handle_random_sample(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.random_sample(
        nonce0=args.nonce0,
        nonce1=args.nonce1,
        total_mass=args.total_mass,
        block_number=args.block_number,
    )
    print(result)


def handle_resolve(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.resolve(
        pitch=args.pitch, swing=args.swing, block_number=args.block_number
    )
    print(result)


def handle_reveal_pitch(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.reveal_pitch(
        session_id=args.session_id,
        nonce=args.nonce_arg,
        speed=args.speed,
        vertical=args.vertical,
        horizontal=args.horizontal,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_reveal_swing(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.reveal_swing(
        session_id=args.session_id,
        nonce=args.nonce_arg,
        kind=args.kind,
        vertical=args.vertical,
        horizontal=args.horizontal,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_sample_outcome_from_distribution(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.sample_outcome_from_distribution(
        nonce0=args.nonce0,
        nonce1=args.nonce1,
        distribution=args.distribution,
        block_number=args.block_number,
    )
    print(result)


def handle_session_hash(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.session_hash(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_session_progress(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.session_progress(
        session_id=args.session_id, block_number=args.block_number
    )
    print(result)


def handle_start_session(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.start_session(
        nft_address=args.nft_address,
        token_id=args.token_id,
        role=args.role,
        require_signature=args.require_signature,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def handle_swing_hash(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    result = contract.swing_hash(
        nonce=args.nonce_arg,
        kind=args.kind,
        vertical=args.vertical,
        horizontal=args.horizontal,
        block_number=args.block_number,
    )
    print(result)


def handle_unstake_nft(args: argparse.Namespace) -> None:
    network.connect(args.network)
    contract = Fullcount(args.address)
    transaction_config = get_transaction_config(args)
    result = contract.unstake_nft(
        nft_address=args.nft_address,
        token_id=args.token_id,
        transaction_config=transaction_config,
    )
    print(result)
    if args.verbose:
        print(result.info())


def generate_cli() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="CLI for Fullcount")
    parser.set_defaults(func=lambda _: parser.print_help())
    subcommands = parser.add_subparsers()

    deploy_parser = subcommands.add_parser("deploy")
    add_default_arguments(deploy_parser, True)
    deploy_parser.add_argument(
        "--seconds-per-phase", required=True, help="Type: uint256", type=int
    )
    deploy_parser.set_defaults(func=handle_deploy)

    verify_contract_parser = subcommands.add_parser("verify-contract")
    add_default_arguments(verify_contract_parser, False)
    verify_contract_parser.set_defaults(func=handle_verify_contract)

    distance0_distribution_parser = subcommands.add_parser("distance0-distribution")
    add_default_arguments(distance0_distribution_parser, False)
    distance0_distribution_parser.add_argument(
        "--arg1", required=True, help="Type: uint256", type=int
    )
    distance0_distribution_parser.set_defaults(func=handle_distance0_distribution)

    distance1_distribution_parser = subcommands.add_parser("distance1-distribution")
    add_default_arguments(distance1_distribution_parser, False)
    distance1_distribution_parser.add_argument(
        "--arg1", required=True, help="Type: uint256", type=int
    )
    distance1_distribution_parser.set_defaults(func=handle_distance1_distribution)

    distance2_distribution_parser = subcommands.add_parser("distance2-distribution")
    add_default_arguments(distance2_distribution_parser, False)
    distance2_distribution_parser.add_argument(
        "--arg1", required=True, help="Type: uint256", type=int
    )
    distance2_distribution_parser.set_defaults(func=handle_distance2_distribution)

    distance_gt2_distribution_parser = subcommands.add_parser(
        "distance-gt2-distribution"
    )
    add_default_arguments(distance_gt2_distribution_parser, False)
    distance_gt2_distribution_parser.add_argument(
        "--arg1", required=True, help="Type: uint256", type=int
    )
    distance_gt2_distribution_parser.set_defaults(func=handle_distance_gt2_distribution)

    fullcount_version_parser = subcommands.add_parser("fullcount-version")
    add_default_arguments(fullcount_version_parser, False)
    fullcount_version_parser.set_defaults(func=handle_fullcount_version)

    num_sessions_parser = subcommands.add_parser("num-sessions")
    add_default_arguments(num_sessions_parser, False)
    num_sessions_parser.set_defaults(func=handle_num_sessions)

    seconds_per_phase_parser = subcommands.add_parser("seconds-per-phase")
    add_default_arguments(seconds_per_phase_parser, False)
    seconds_per_phase_parser.set_defaults(func=handle_seconds_per_phase)

    session_state_parser = subcommands.add_parser("session-state")
    add_default_arguments(session_state_parser, False)
    session_state_parser.add_argument(
        "--arg1", required=True, help="Type: uint256", type=int
    )
    session_state_parser.set_defaults(func=handle_session_state)

    staked_session_parser = subcommands.add_parser("staked-session")
    add_default_arguments(staked_session_parser, False)
    staked_session_parser.add_argument("--arg1", required=True, help="Type: address")
    staked_session_parser.add_argument(
        "--arg2", required=True, help="Type: uint256", type=int
    )
    staked_session_parser.set_defaults(func=handle_staked_session)

    abort_session_parser = subcommands.add_parser("abort-session")
    add_default_arguments(abort_session_parser, True)
    abort_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    abort_session_parser.set_defaults(func=handle_abort_session)

    commit_pitch_parser = subcommands.add_parser("commit-pitch")
    add_default_arguments(commit_pitch_parser, True)
    commit_pitch_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    commit_pitch_parser.add_argument(
        "--signature", required=True, help="Type: bytes", type=bytes_argument_type
    )
    commit_pitch_parser.set_defaults(func=handle_commit_pitch)

    commit_swing_parser = subcommands.add_parser("commit-swing")
    add_default_arguments(commit_swing_parser, True)
    commit_swing_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    commit_swing_parser.add_argument(
        "--signature", required=True, help="Type: bytes", type=bytes_argument_type
    )
    commit_swing_parser.set_defaults(func=handle_commit_swing)

    eip712_domain_parser = subcommands.add_parser("eip712-domain")
    add_default_arguments(eip712_domain_parser, False)
    eip712_domain_parser.set_defaults(func=handle_eip712_domain)

    get_session_parser = subcommands.add_parser("get-session")
    add_default_arguments(get_session_parser, False)
    get_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    get_session_parser.set_defaults(func=handle_get_session)

    join_session_parser = subcommands.add_parser("join-session")
    add_default_arguments(join_session_parser, True)
    join_session_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    join_session_parser.add_argument(
        "--nft-address", required=True, help="Type: address"
    )
    join_session_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    join_session_parser.add_argument(
        "--signature", required=True, help="Type: bytes", type=bytes_argument_type
    )
    join_session_parser.set_defaults(func=handle_join_session)

    pitch_hash_parser = subcommands.add_parser("pitch-hash")
    add_default_arguments(pitch_hash_parser, False)
    pitch_hash_parser.add_argument(
        "--nonce-arg", required=True, help="Type: uint256", type=int
    )
    pitch_hash_parser.add_argument(
        "--speed", required=True, help="Type: uint8", type=int
    )
    pitch_hash_parser.add_argument(
        "--vertical", required=True, help="Type: uint8", type=int
    )
    pitch_hash_parser.add_argument(
        "--horizontal", required=True, help="Type: uint8", type=int
    )
    pitch_hash_parser.set_defaults(func=handle_pitch_hash)

    random_sample_parser = subcommands.add_parser("random-sample")
    add_default_arguments(random_sample_parser, False)
    random_sample_parser.add_argument(
        "--nonce0", required=True, help="Type: uint256", type=int
    )
    random_sample_parser.add_argument(
        "--nonce1", required=True, help="Type: uint256", type=int
    )
    random_sample_parser.add_argument(
        "--total-mass", required=True, help="Type: uint256", type=int
    )
    random_sample_parser.set_defaults(func=handle_random_sample)

    resolve_parser = subcommands.add_parser("resolve")
    add_default_arguments(resolve_parser, False)
    resolve_parser.add_argument("--pitch", required=True, help="Type: tuple", type=eval)
    resolve_parser.add_argument("--swing", required=True, help="Type: tuple", type=eval)
    resolve_parser.set_defaults(func=handle_resolve)

    reveal_pitch_parser = subcommands.add_parser("reveal-pitch")
    add_default_arguments(reveal_pitch_parser, True)
    reveal_pitch_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    reveal_pitch_parser.add_argument(
        "--nonce-arg", required=True, help="Type: uint256", type=int
    )
    reveal_pitch_parser.add_argument(
        "--speed", required=True, help="Type: uint8", type=int
    )
    reveal_pitch_parser.add_argument(
        "--vertical", required=True, help="Type: uint8", type=int
    )
    reveal_pitch_parser.add_argument(
        "--horizontal", required=True, help="Type: uint8", type=int
    )
    reveal_pitch_parser.set_defaults(func=handle_reveal_pitch)

    reveal_swing_parser = subcommands.add_parser("reveal-swing")
    add_default_arguments(reveal_swing_parser, True)
    reveal_swing_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    reveal_swing_parser.add_argument(
        "--nonce-arg", required=True, help="Type: uint256", type=int
    )
    reveal_swing_parser.add_argument(
        "--kind", required=True, help="Type: uint8", type=int
    )
    reveal_swing_parser.add_argument(
        "--vertical", required=True, help="Type: uint8", type=int
    )
    reveal_swing_parser.add_argument(
        "--horizontal", required=True, help="Type: uint8", type=int
    )
    reveal_swing_parser.set_defaults(func=handle_reveal_swing)

    sample_outcome_from_distribution_parser = subcommands.add_parser(
        "sample-outcome-from-distribution"
    )
    add_default_arguments(sample_outcome_from_distribution_parser, False)
    sample_outcome_from_distribution_parser.add_argument(
        "--nonce0", required=True, help="Type: uint256", type=int
    )
    sample_outcome_from_distribution_parser.add_argument(
        "--nonce1", required=True, help="Type: uint256", type=int
    )
    sample_outcome_from_distribution_parser.add_argument(
        "--distribution", required=True, help="Type: uint256[7]", nargs="+"
    )
    sample_outcome_from_distribution_parser.set_defaults(
        func=handle_sample_outcome_from_distribution
    )

    session_hash_parser = subcommands.add_parser("session-hash")
    add_default_arguments(session_hash_parser, False)
    session_hash_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    session_hash_parser.set_defaults(func=handle_session_hash)

    session_progress_parser = subcommands.add_parser("session-progress")
    add_default_arguments(session_progress_parser, False)
    session_progress_parser.add_argument(
        "--session-id", required=True, help="Type: uint256", type=int
    )
    session_progress_parser.set_defaults(func=handle_session_progress)

    start_session_parser = subcommands.add_parser("start-session")
    add_default_arguments(start_session_parser, True)
    start_session_parser.add_argument(
        "--nft-address", required=True, help="Type: address"
    )
    start_session_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    start_session_parser.add_argument(
        "--role", required=True, help="Type: uint8", type=int
    )
    start_session_parser.add_argument(
        "--require-signature",
        required=True,
        help="Type: bool",
        type=boolean_argument_type,
    )
    start_session_parser.set_defaults(func=handle_start_session)

    swing_hash_parser = subcommands.add_parser("swing-hash")
    add_default_arguments(swing_hash_parser, False)
    swing_hash_parser.add_argument(
        "--nonce-arg", required=True, help="Type: uint256", type=int
    )
    swing_hash_parser.add_argument(
        "--kind", required=True, help="Type: uint8", type=int
    )
    swing_hash_parser.add_argument(
        "--vertical", required=True, help="Type: uint8", type=int
    )
    swing_hash_parser.add_argument(
        "--horizontal", required=True, help="Type: uint8", type=int
    )
    swing_hash_parser.set_defaults(func=handle_swing_hash)

    unstake_nft_parser = subcommands.add_parser("unstake-nft")
    add_default_arguments(unstake_nft_parser, True)
    unstake_nft_parser.add_argument(
        "--nft-address", required=True, help="Type: address"
    )
    unstake_nft_parser.add_argument(
        "--token-id", required=True, help="Type: uint256", type=int
    )
    unstake_nft_parser.set_defaults(func=handle_unstake_nft)

    return parser


def main() -> None:
    parser = generate_cli()
    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
